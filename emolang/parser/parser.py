from emolang.lexer import TokenType, SyntaxException
from emolang.parser.nodes import (
    AssignmentNode,
    AdditionNode,
    MultiplicationNode,
    IfNode,
    ElseIfNode,
    ElseNode,
    SubtractionNode,
    ModulusNode,
    DivisionNode,
    ExponentNode,
    BlockNode,
    NumberLiteralNode,
    PrintNode,
    StringLiteralNode,
    VariableNode,
    BinaryOperationContext,
    AndNode,
    EqualsNode,
    GreaterNode,
    GreaterEqualsNode,
    LessNode,
    LessEqualsNode,
    NotNode,
    NotEqualsNode,
    OrNode,
    BooleanLiteralNode,
    UnaryOperationContext,
    ReassignmentNode,
    LoopNode,
    BlockScope,
    BreakNode,
    ContinueNode
)
from emolang.parser.parser_state import ParserState


class Parser:
    """
    The Parser class is responsible for transforming a list of tokens into an Abstract Syntax Tree (AST).
    It handles parsing variable assignments, expressions, operations, and print statements.
    The algorithm used here to construct the AST is recursive descent parsing.
    """

    def __init__(self, tokens):
        """
        Initializes the parser with a list of tokens.

        :param tokens: The list of tokens generated by the lexer.
        """
        self._state = ParserState(tokens)

    def parse(self):
        """
        The main entry point for parsing. It loops through the tokens and parses each one,
        generating a BlockNode (AST root) containing all parsed nodes.

        :return: BlockNode representing the entire parsed program.
        """
        line_number = self._state.current_line_number()
        nodes = []
        while self._state.in_bounds(self._state.get_current()) and not self._state.is_eof_token():
            node = self._handle_token()
            nodes.append(node)
        return BlockNode(nodes, self._state.get_block_scope(), line_number)

    def _handle_token(self, index=None, context=None):
        """
        Handles a token based on its type. This function delegates token-specific logic to
        different parsing methods (e.g., print, identifier, variable).

        :param index: The current token index (defaults to _current).
        :param context: Context for operation nodes.
        :return: A parsed node corresponding to the token.
        """
        if index is None:
            index = self._state.get_current()
        token = self._state.retrieve_token(index)
        if token.is_token_type(TokenType.PRINT):
            return self._parse_print_token()
        if token.is_token_type(TokenType.IDENTIFIER):
            if self._is_reassignment_statement(index):
                return self._parse_reassignment()
            return self._parse_identifier_token(index)
        if token.is_token_type(TokenType.VAR):
            return self._parse_var_token()
        if token.is_token_type(TokenType.IF):
            return self._parse_if_statement()
        if token.is_token_type(TokenType.BREAK):
            return self._parse_break()
        if token.is_token_type(TokenType.CONTINUE):
            return self._parse_continue()
        if token.is_token_type(TokenType.LOOP):
            return self._parse_loop()
        if token.get_token_type() in TokenType.literal_types():
            return self._parse_literal(token)
        if token.get_token_type() in TokenType.operation_types():
            return self._parse_operation(token, context)

    def _parse_print_token(self):
        """
        Parses a print statement. The expected structure is:
        üó£Ô∏è <expression> ;

        :return: PrintNode representing the print statement.
        """
        line_number = self._validate_token({TokenType.PRINT}, "Expected 'üó£Ô∏è' for print statement.")
        node_to_print = self._parse_expression()
        self._validate_token({TokenType.SEMI_COLON}, "Expected ';' to terminate statement.")
        return PrintNode(node_to_print, line_number)

    def _validate_token(self, valid_token_types, error_message):
        """
        Validates that the current token matches one of the expected types. Raises a SyntaxException if not.

        :param valid_token_types: A set of token types that are valid while parsing this token.
        :param error_message: The error message to raise if validation fails.
        """
        current_token = self._state.current_token()
        token_line_number = current_token.get_line()
        if current_token.get_token_type() not in valid_token_types:
            raise SyntaxException(token_line_number, error_message)
        self._state.advance_current()
        return token_line_number

    def _is_reassignment_statement(self, index):
        """
        Determines if an identifier is part of a statement that represents
        a variable reassignment.

        :param index: The index of the identifier token.
        :return: if the statement is for variable reassignment.
        """
        previous_token, next_token = self._state.retrieve_token(index - 1), self._state.retrieve_token(index + 1)
        return next_token.is_token_type(TokenType.EQUAL) and not previous_token.is_token_type(TokenType.VAR)

    def _parse_identifier_token(self, index):
        """
        Parses an identifier token, which represents an individual variable or represents
        a variable reassignment.

        :param index: The index of the identifier token.
        :return: VariableNode representing the variable or ReassignmentNode with variable and new value.
        """
        identifier_token = self._state.retrieve_token(index)
        return VariableNode(identifier_token.get_lexeme(), identifier_token.get_line())

    def _parse_reassignment(self):
        """
        Parses a reassignment statement in the source code.

        :return: ReassignmentNode representing the reassignment of a variable.
        """
        variable_node, value_node, line_number = self._parse_assignment()
        return ReassignmentNode(variable_node, value_node, line_number)

    def _parse_assignment(self):
        """
        Parses an assignment statement in the source code.

        :return: tuple: A tuple containing the following:
            - VariableNode: A node representing the variable being assigned or reassigned.
            - AbstractSyntaxTreeNode: A node representing the value assigned to the variable.
            - int: The line number where the assignment occurs.
        :raises: SyntaxException if the assignment statement is invalid, such as missing an identifier, assignment operator, or semicolon.
        """
        variable_node = self._parse_identifier_token(self._state.get_current())
        line_number = self._validate_token({TokenType.IDENTIFIER}, "Expected an identifier for assignment.")
        self._validate_token({TokenType.EQUAL}, "Expected '‚úçÔ∏è' for assignment.")
        value_node = self._parse_expression()
        self._validate_token({TokenType.SEMI_COLON}, "Expected ';' to terminate the statement.")
        return variable_node, value_node, line_number

    def _parse_var_token(self):
        """
        Parses a variable declaration or assignment. The expected structure is:
        ü•∏ <identifier> ‚úçÔ∏è <expression> ;

        :return: AssignmentNode representing the variable assignment.
        """
        self._validate_token({TokenType.VAR}, "Expected 'ü•∏' to indicate variable.")
        variable_node, value_node, line_number = self._parse_assignment()
        return AssignmentNode(variable_node, value_node, line_number)

    def _parse_expression(self):
        """
        Parses an expression up to the specified end token (such as a semicolon or a right brace).

        :return: The root node of the parsed expression.
        """
        end_of_expression_index = self._find_end_of_expression_index()
        node = self._parse_expression_recursive(self._state.get_current(), end_of_expression_index - 1)
        self._state.set_current(end_of_expression_index)
        return node

    def _find_end_of_expression_index(self):
        """
        Finds the index of the end of the expression specified token (such as a semicolon).
        This is done by iterating until it encounters a token that shouldn't be found in
        an expression.

        :return: The index of the end of expression.
        """
        index = self._state.get_current()
        valid_expression_tokens = TokenType.valid_expression_types()
        while self._state.retrieve_token(index).get_token_type() in valid_expression_tokens:
            index += 1
        return index

    def _parse_expression_recursive(self, left_index, right_index):
        """
        Recursively parses an expression within the given token range. Handles precedence and parentheses.

        :param left_index: The left bound of the token range.
        :param right_index: The right bound of the token range.
        :return: The parsed expression node.
        """
        left_token, right_token = self._state.retrieve_token(left_index), self._state.retrieve_token(right_index)
        index_delta = right_index - left_index
        if index_delta == 0:
            token_type = left_token.get_token_type()
            if token_type not in TokenType.valid_expression_types():
                raise SyntaxException(left_token.get_line(), f"Invalid token in expression: {token_type}")
            return self._handle_token(left_index)
        if self._is_nested_parens(left_index, right_index):
            return self._parse_expression_recursive(left_index + 1, right_index - 1)
        operator_precedence = [
            {TokenType.OR},
            {TokenType.AND},
            {TokenType.EQUAL_EQUAL, TokenType.GREATER, TokenType.GREATER_EQUAL, TokenType.LESS_EQUAL, TokenType.LESS, TokenType.BANG_EQUAL},
            {TokenType.BANG},
            {TokenType.MINUS, TokenType.PLUS},
            {TokenType.MULTIPLY, TokenType.DIVIDE, TokenType.MODULUS},
            {TokenType.EXPONENT}
        ]
        for operators in operator_precedence:
            index = left_index
            while index < right_index:
                token = self._state.retrieve_token(index)
                if token.is_token_type(TokenType.LEFT_PAREN):
                    index = self._skip_parentheses(index, right_index)
                node = self._handle_by_operations(operators, left_index, right_index, index)
                if node:
                    return node
                index += 1

        raise SyntaxException(
            self._state.retrieve_token(left_index).get_line(),
            "Invalid expression: no valid operations found."
        )

    def _is_nested_parens(self, left_index, right_index):
        """
        Checks if the parentheses between the given left and right indices are nested,
        meaning that the parentheses are part of the same nested group.

        :param left_index: The index of the left parenthesis.
        :param right_index: The index of the right bound for the search.
        :return: `True` if the parentheses are nested, `False` otherwise.
        """
        if not self._within_parens(left_index, right_index):
            return False

        paren_counter, end_index = self._find_parenthesis_count(left_index, right_index)
        return paren_counter == 0 and end_index == right_index

    def _find_parenthesis_count(self, left_index, right_index):
        """
        Scans the tokens between `left_index` and `right_index` to find where a set of parentheses closes
        and the balance of parentheses between the bounds.

        :param left_index: The index of the left parenthesis `'('` where the search begins.
        :param right_index: The index of the right bound for the search.
        :return: A tuple containing:
            - `paren_counter` (int): The final count of parentheses (should be zero if parentheses are balanced).
            - `current_index` (int): The index at which the parentheses balance returns to zero.
        :raises SyntaxException: If there are unmatched left or right parentheses within the given range.
        """
        paren_counter = 0
        current_index = left_index
        while current_index <= right_index:
            token = self._state.retrieve_token(current_index)
            if token.is_token_type(TokenType.LEFT_PAREN):
                paren_counter += 1
            if token.is_token_type(TokenType.RIGHT_PAREN):
                paren_counter -= 1
            if paren_counter == 0:
                break
            current_index += 1

        token_line = self._state.retrieve_token(right_index).get_line()
        if paren_counter > 0:
            raise SyntaxException(token_line, 'Left parenthesis missing closing right.')
        elif paren_counter < 0:
            raise SyntaxException(token_line, 'Right parenthesis missing corresponding left.')
        return paren_counter, current_index

    def _within_parens(self, left_index, right_index):
        """
        Checks if the given tokens are within parentheses.

        :param left_index: The left token index.
        :param right_index: The right token index.
        :return: True if the tokens are within parentheses, False otherwise.
        """
        left_token, right_token = self._state.retrieve_token(left_index), self._state.retrieve_token(right_index)
        return left_token.is_token_type(TokenType.LEFT_PAREN) and right_token.is_token_type(TokenType.RIGHT_PAREN)

    def _skip_parentheses(self, left_index, right_index):
        """
        Skips over a section of tokens enclosed in parentheses.

        :param left_index: The starting index (left parenthesis).
        :param right_index: The ending index.
        :return: The index of the token after the closing parenthesis.
        """
        paren_counter, end_index = self._find_parenthesis_count(left_index, right_index)
        return min(end_index + 1, right_index)

    def _handle_by_operations(self, operations, left_index, right_index, index):
        """
        Handles binary and unary operations based on operator precedence.

        :param operations: Set of operations to process.
        :param left_index: Left bound of the expression.
        :param right_index: Right bound of the expression.
        :param index: Current token index.
        :return: Node representing the operation, or None if no operation was found.
        """
        token = self._state.retrieve_token(index)
        token_type = token.get_token_type()
        if token_type in operations:
            if token_type in TokenType.unary_operations():
                return self._handle_unary_operation(index, right_index)
            else:
                return self._handle_binary_operation(left_index, index, right_index)

    def _handle_unary_operation(self, index, right_index):
        """
        Handles unary operations (such as negation).

        :param index: The index of the unary operator.
        :param right_index: The right bound of the expression.
        :return: Node representing the unary operation.
        """
        token = self._state.retrieve_token(index)
        right_node = self._parse_expression_recursive(index + 1, right_index)
        if right_node is None:
            raise SyntaxException(token.get_line(), "Invalid expression: missing right operand.")
        context = UnaryOperationContext(right_node)
        return self._handle_token(index, context)

    def _handle_binary_operation(self, left_index, index, right_index):
        """
        Handles binary operations (such as addition, subtraction, etc.).

        :param left_index: Left bound of the left operand.
        :param index: The index of the operator.
        :param right_index: Right bound of the right operand.
        :return: Node representing the binary operation.
        """
        token = self._state.retrieve_token(index)
        left_node = self._parse_expression_recursive(left_index, index - 1)
        if left_node is None:
            raise SyntaxException(token.get_line(), "Invalid expression: missing left operand.")

        right_node = self._parse_expression_recursive(index + 1, right_index)
        if right_node is None:
            raise SyntaxException(token.get_line(), "Invalid expression: missing right operand.")

        context = BinaryOperationContext(left_node, right_node)
        return self._handle_token(index, context)

    def _parse_if_statement(self):
        """
        Parses an if statement in the source code.

        :return: An IfNode representing the parsed if statement.
        """
        line_number = self._validate_token({TokenType.IF}, "Expected 'ü§î' for if statement.")
        condition_node, block_node = self._parse_conditional()
        next_conditional = self._parse_next_if_conditional()
        return IfNode(condition_node, block_node, next_conditional, line_number)

    def _parse_conditional(self):
        """
        Parse the condition and block of an if statement.

        :return: Tuple containing the condition node and block node.
        """
        condition_node = self._parse_expression()
        self._validate_token({TokenType.LEFT_BRACE}, "Expected '{' to begin if statement block.")
        if_block_node = self._parse_block()
        self._validate_token({TokenType.RIGHT_BRACE}, "Expected '}' to begin if statement block.")
        return condition_node, if_block_node

    def _parse_block(self):
        """
        Parses a block of code enclosed in curly braces `{}`. If no closing brace
        is found, it raises a SyntaxException.

        :return: A BlockNode representing the parsed block of code.
        """
        line_number = self._state.current_line_number()
        nodes = []
        while not self._state.current_token().is_token_type(TokenType.RIGHT_BRACE):
            if self._state.is_eof_token():
                raise SyntaxException(self._state.current_token().get_line(), "Missing closing right brace.")
            node = self._handle_token()
            nodes.append(node)
        return BlockNode(nodes, self._state.get_block_scope(), line_number)

    def _parse_next_if_conditional(self):
        """
        Parses an optional elseif block chain in an if statement.

        :return: A BlockNode representing the elseif node or None if not present.
        """
        current_token = self._state.current_token()
        if current_token.is_token_type(TokenType.ELSE):
            return self._parse_else()
        if current_token.get_token_type() not in TokenType.if_statement_tokens():
            return
        if current_token.is_token_type(TokenType.ELSEIF):
            line_number = self._validate_token({TokenType.ELSEIF}, "Expected 'üôà' for elseif statement.")
            condition_node, block_node = self._parse_conditional()
            next_conditional = self._parse_next_if_conditional()
            return ElseIfNode(condition_node, block_node, next_conditional, line_number)

    def _parse_else(self):
        """
        Parses an optional else block in an if statement.

        :return: A BlockNode representing the else block or None if no else block is present.
        """
        if self._state.current_token().is_token_type(TokenType.ELSE):
            line_number = self._validate_token({TokenType.ELSE}, "Expected 'üíÖ' for else.")
            self._validate_token({TokenType.LEFT_BRACE}, "Expected '{' to begin else block.")
            else_block_node = self._parse_block()
            self._validate_token({TokenType.RIGHT_BRACE}, "Expected '}' to begin else block.")
            return ElseNode(else_block_node, line_number)

    def _parse_break(self):
        """
        Parses a break statement in the source code which is used to exit a loop prematurely.

        :return: A BreakNode representing the break.
        :raise: SyntaxException if the 'üí•' token or the terminating semicolon is missing.
        """
        line_number = self._validate_token({TokenType.BREAK}, "Expected 'üí•' for break.")
        self._validate_token({TokenType.SEMI_COLON}, "Expected ';' to terminate statement.")
        return BreakNode(line_number)

    def _parse_continue(self):
        """
        Parses a continue statement in the source code which is used to skip the rest of the current loop.

        :return: A ContinueNode representing the continue.
        :raise: SyntaxException if the 'ü§ì' token or the terminating semicolon is missing.
        """
        line_number = self._validate_token({TokenType.CONTINUE}, "Expected 'ü§ì' for continue.")
        self._validate_token({TokenType.SEMI_COLON}, "Expected ';' to terminate statement.")
        return ContinueNode(line_number)

    def _parse_loop(self):
        """
        Parses a loop in the source code.

        :return: An LoopNode representing the parsed loop.
        """
        previous_block_scope = self._state.get_block_scope()
        self._state.set_block_scope(BlockScope.LOOP)
        line_number = self._validate_token({TokenType.LOOP}, "Expected 'üîÅ' for loop.")
        condition_node = self._parse_expression()
        self._validate_token({TokenType.LEFT_BRACE}, "Expected '{' to begin if statement block.")
        loop_block_node = self._parse_block()
        self._validate_token({TokenType.RIGHT_BRACE}, "Expected '}' to begin if statement block.")
        self._state.set_block_scope(previous_block_scope)
        return LoopNode(condition_node, loop_block_node, line_number)

    def _parse_literal(self, token):
        """
        Parses a literal token (e.g., string, number, boolean).

        :param token: The literal token to parse.
        :return: Node representing the literal value.
        """
        line_number = self._state.current_line_number()
        if token.is_token_type(TokenType.STRING):
            return StringLiteralNode(token.get_literal(), line_number)
        if token.is_token_type(TokenType.NUMBER):
            return NumberLiteralNode(token.get_literal(), line_number)
        if token.is_token_type(TokenType.TRUE):
            return BooleanLiteralNode(True, line_number)
        if token.is_token_type(TokenType.FALSE):
            return BooleanLiteralNode(False, line_number)

    def _parse_operation(self, token, context):
        """
        Parses an operation token and returns the appropriate operation node based on the context.

        :param token: The operation token to parse.
        :param context: The context (unary or binary) in which the operation occurs.
        :return: The corresponding operation node.
        """
        binary_operation_map = {
            TokenType.AND: AndNode,
            TokenType.BANG_EQUAL: NotEqualsNode,
            TokenType.DIVIDE: DivisionNode,
            TokenType.EQUAL_EQUAL: EqualsNode,
            TokenType.EXPONENT: ExponentNode,
            TokenType.GREATER: GreaterNode,
            TokenType.GREATER_EQUAL: GreaterEqualsNode,
            TokenType.LESS: LessNode,
            TokenType.LESS_EQUAL: LessEqualsNode,
            TokenType.MINUS: SubtractionNode,
            TokenType.MODULUS: ModulusNode,
            TokenType.MULTIPLY: MultiplicationNode,
            TokenType.OR: OrNode,
            TokenType.PLUS: AdditionNode,
        }
        token_type = token.get_token_type()
        line_number = token.get_line()
        if token_type in binary_operation_map:
            operation_class = binary_operation_map[token_type]
            left_operand, right_operand = context.get_left_operand(), context.get_right_operand()
            return operation_class(left_operand, right_operand, line_number)

        if token.is_token_type(TokenType.BANG):
            return NotNode(context.get_operand(), line_number)
